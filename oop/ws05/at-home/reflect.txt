{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red27\green29\blue31;\red255\green255\blue0;}
{\*\expandedcolortbl;;\csgenericrgb\c10588\c11373\c12157;\csgenericrgb\c100000\c100000\c0;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\ri0\partightenfactor0

\f0\fs23 \cf2 // Name Mohammad Sharafiafar \'a0 \'a0 \'a0 \'a0 6/02/2019\'a0 \'a0 \'a0 \'a0 \'a0 lab section SAA\'a0 \'a0 \'a0 \'a0 Student ID : 143473171\
\
\
1)\'a0\
The operator+ returns a Fraction object. Explain why this operator should not return a reference to a Fraction object (like operator+=).\'a0\
\
Answer:\'a0\
\
\'a0 A bit of clarification as to why it's preferable to return by reference for\'a0operator+=\'a0versus return by value\'a0 as the chain\'a0a += b\'a0will work fine if a value is returned.\
If you return a reference, minimal work is done. The values from one object are copied to another object.\
However, if you return by value for\'a0operator+=, you will call a constructor AND destructor EACH time that the assignment operator is called!!\
\
\
2)\
List the temporary objects in the tester module (the temporary objects are those that have no name and are removed from memory immediately after their creation; put messages in the constructors/destructor to reveal them).\'a0\
\
\
Answer:\
\'a0\'a0 In main.cpp part a+b, a*c etc these things are temporary objects3)Explain why the canTravelWith(...) member function can access the pri-vate data of the object referenced in its parameter.\'a0\
\
Fraction temp;\
\'a0 \'a0 \'a0 \'a0 //bool valid = isValid(*this) && isValid(rhs);\
\'a0 \'a0 \'a0 \'a0 if(rhs.numerator >= 0 && rhs.denominator > 0)\
\'a0\'a0 \'a0 \'a0 \'a0 \'a0 // if(numerator.(*this) >=0 &&denominator.(*this) >0)\
\'a0 \'a0 \'a0 \'a0 \{\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 temp.numerator = this->numerator * rhs.numerator;\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 temp.denominator = this->denominator * rhs.denominator;\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 return temp;\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 else\
\'a0 \'a0 \'a0 \'a0 \{\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 temp = Fraction();\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 return temp;\
\'a0 \'a0 \'a0 \'a0 \}\
\
\
and\'a0\
\
\
Fraction Fraction::operator+(const Fraction& rhs) const\
\'a0 \'a0 \{\
\'a0 \'a0 \'a0 \'a0 Fraction tmp(1, -1);\
\'a0 \'a0 \'a0 \'a0 if (isEmpty() == false && rhs.isEmpty() == false)\{\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 tmp.numerator = ((numerator*rhs.denominator) + (rhs.numerator*denominator));\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 tmp.denominator =(denominator*rhs.denominator);\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 return tmp;\
\'a0 \'a0 \}\
\
3\
List the simplifications that you made to your class to minimize duplication.\'a0\
\
\
\'a0 bool operator==(const Fraction& rhs) const;\
\'a0 bool operator!=(const Fraction& rhs) const;\
\'a0 Fraction& operator+=(const Fraction& rhs);\
\'a0 bool Fraction_Equal(const Fraction& a, const Fraction& b) const;\
\
\'a0 bool isEmpty() const;\
\'a0 void display() const;\
\pard\pardeftab720\ri0\partightenfactor0

\f1\fs24 \cf3 \
}